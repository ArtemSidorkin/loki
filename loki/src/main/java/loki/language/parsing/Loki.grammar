grammar Loki;



@header
{
package loki.language.parsing;
}



module : (instruction SEMICOLON)+;



instruction : expression;



expression:

	LEFT_PARENTHESIS (BEGIN)? expression (SEMICOLON)? (END)? RIGHT_PARENTHESIS #ExpressionGroup |



	LEFT_BRACKET (expression (COMMA expression)*)? RIGHT_BRACKET #Array |

	LEFT_BRACKET
	(
		(
			BEGIN
				expression RIGHT_THIN_ARROW expression (COMMA expression RIGHT_THIN_ARROW expression)* (SEMICOLON)?
			END
		) |
		(expression RIGHT_THIN_ARROW expression (COMMA expression RIGHT_THIN_ARROW expression)* (SEMICOLON)?) |
		(MINUS)
	)
	RIGHT_BRACKET (SEMICOLON)? (END)?
	#Map |



	LEFT_BRACKET
	(
		(
			BEGIN
				expression RIGHT_THICK_ARROW expression (COMMA expression RIGHT_THICK_ARROW expression)* (SEMICOLON)?
			END
		) |
		(expression RIGHT_THICK_ARROW expression (COMMA expression RIGHT_THICK_ARROW expression)* (SEMICOLON)?)? |
		EQUALS
	)
	RIGHT_BRACKET
	#Object |



	DOLLAR #Host |



	AT #This |



	CHARACTERS #String |
	ACUTE IDENTIFIER #String |



	FLOAT #Number |
	INT #Number |



	(((DOLLAR)? head=(IDENTIFIER | UNDERSCORE) (IDENTIFIER)* (inheritance)? COLON) | BACKSLASH)
	(
		instruction |
		(
			BEGIN
				(instruction SEMICOLON)+
			END
		)
	)
	#Unit |

	expression DOT IDENTIFIER LEFT_PARENTHESIS RIGHT_PARENTHESIS #MemberCall |

	expression DOT IDENTIFIER LEFT_PARENTHESIS
		(BEGIN)?
			expression (COMMA expression)* (SEMICOLON)?
		(END)?
	RIGHT_PARENTHESIS
	#MemberCall |



	DOLLAR DOLLAR IDENTIFIER #SuperHostMember |
	DOLLAR IDENTIFIER #HostMember |
	(IDENTIFIER | UNDERSCORE) #VariableOrParameter |
	expression DOT IDENTIFIER #Member |
	expression LEFT_BRACKET (BEGIN)? expression (SEMICOLON)? (END)? RIGHT_BRACKET #Index |
	expression DOLLAR LEFT_BRACKET ((BEGIN expression SEMICOLON END) | expression) RIGHT_BRACKET #MemberAccessor |



	expression LEFT_PARENTHESIS RIGHT_PARENTHESIS #Call |

	expression LEFT_PARENTHESIS
		(BEGIN)?
			expression (COMMA expression)* (SEMICOLON)?
		(END)?
	RIGHT_PARENTHESIS
	#Call |



	operator=MINUS expression #UnaryOperation |
	operator=BANG expression #UnaryOperation |



	expression operator=(STAR | SLASH) expression #BinaryOperation |
	expression operator=(PLUS | MINUS) expression #BinaryOperation |
	expression operator=(EQUALS_EQUALS | BANG_EQUALS) expression #BinaryOperation |
	expression operator=(GREATER_THAN_EQUALS | LESS_THAN_EQUALS | GREATER_THAN | LESS_THAN) expression #BinaryOperation |
	expression operator=(AMPERSAND_AMPERSAND | AMPERSAND_AMPERSAND) expression #BinaryOperation |
	expression operator=(PIPE_PIPE | PIPE_PIPE) expression #BinaryOperation |



	DOLLAR IDENTIFIER EQUALS expression #AssignHostMember |
	DOLLAR IDENTIFIER EQUALS BEGIN expression SEMICOLON END #AssignHostMember |



	IDENTIFIER EQUALS expression #AssignVariable |
	IDENTIFIER EQUALS BEGIN expression SEMICOLON END #AssignVariable |



	expression DOT IDENTIFIER EQUALS expression #AssignMember |
	expression DOT IDENTIFIER EQUALS SEMICOLON BEGIN expression END #AssignMember |



	expression LEFT_BRACKET
		(BEGIN)?
			expression
		(END)?
	RIGHT_BRACKET EQUALS expression
	#AssignIndex |

	expression LEFT_BRACKET
		(BEGIN)?
			expression
		(END)?
	RIGHT_BRACKET EQUALS BEGIN expression SEMICOLON END
	#AssignIndex |



	expression DOLLAR LEFT_BRACKET
	 	((BEGIN expression SEMICOLON END) | expression)
	RIGHT_BRACKET EQUALS ((BEGIN expression SEMICOLON END) | expression)?
	#AssignMemberAccessor |


	IF (BEGIN)? expression (SEMICOLON)? (END)? COLON instruction (else_)? #IfElse |

	IF
		(BEGIN)?
			expression (SEMICOLON)?
		(END)?
	COLON
		BEGIN
			(instruction SEMICOLON)+
		END
	(else_)?
	#IfElse |



	WHILE (BEGIN)? expression (SEMICOLON)? (END)? COLON instruction #While |

	WHILE
		(BEGIN)?
			expression (SEMICOLON)?
		(END)?
	COLON
		BEGIN
			(instruction SEMICOLON)+
		END
	#While

;



inheritance : DOUBLE_COLON expression | DOUBLE_COLON (expression COMMA)+ expression;



else_ : ELSE BEGIN (instruction SEMICOLON)+ END | ELSE instruction;



BEGIN : LEFT_BRACE;
END : RIGHT_BRACE;



IF : 'if';
ELSE : 'else';
WHILE : 'while';
IDENTIFIER : ('_')*('A'..'Z' | 'a'..'z')+('A'..'Z' | 'a'..'z' | '0'..'9' | '_')*;
UNDERSCORE : '_';
DOLLAR : '$';
AT : '@';
CHARACTERS : '"' ( '\\"' | . )*? '"';
FLOAT : ('0'..'9')+'.'('0'..'9')+;
INT : ('0'..'9')+;
PLUS : '+';
MINUS : '-';
STAR : '*';
SLASH : '/';
BACKSLASH : '\\';
EQUALS_EQUALS : '==';
BANG_EQUALS : '!=';
GREATER_THAN_EQUALS : '>=';
GREATER_THAN : '>';
LESS_THAN_EQUALS : '<=';
LESS_THAN : '<';
AMPERSAND_AMPERSAND : '&&';
PIPE_PIPE : '||';
BANG : '!';
AMPERSAND : '&';
PIPE : '|';
EQUALS : '=';
DOT : '.';
COMMA : ',';
DOUBLE_COLON : '::';
COLON : ':';
RIGHT_THIN_ARROW : '->';
RIGHT_THICK_ARROW : '=>';
SEMICOLON : ';';
LEFT_PARENTHESIS : '(';
RIGHT_PARENTHESIS : ')';
LEFT_BRACKET : '[';
RIGHT_BRACKET : ']';
LEFT_BRACE : '{';
RIGHT_BRACE : '}';
ACUTE : '`';



IGNORE : [ \t\r\n]+ -> skip;
